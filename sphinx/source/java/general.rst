.. _general:

General
=======

Autoboxing
----------
    - A common use for the so-called “wrapper classes” ( eg Integer, Float, Boolean) was to provide a way to get primitives into and out of collections
    - Prior to Java 5, you had to “wrap” a primitive manually before you could put it into a collection
    - Autoboxing is doing this automatically.

    .. code-block:: python
       :linenos:

        Example 1
        List myInts = new ArrayList(); // pre Java 5 declaration
        myInt.add(new Integer(42)); // Use Integer to “wrap” an int

        myInt.add(42) // autoboxing handles it

        Example 2
        Integer y = new Integer(567);
        y++;
        System.out.println(“y = “ + y);

Boxing, ==, and equals()
------------------------

    .. code-block:: python
       :linenos:

        Example 1:
        Integer i1 = 1000;
        Integer i2 = 1000;
        if ( i1 != i2 ) System.out.println(“1”);
        if (i1.equals(i2)) System.out.println(“2”);

        Result : 
        1
        2

    .. code-block:: python
       :linenos:

        Example 2:

        Integer i3 = 10;
        Integer i4 = 10;
        if ( i3 == i4 ) System.out.println(“1”);
        if (i3.equals(i4)) System.out.println(“2”);

        Result : 
        1
        2

    - Why both example, operator != and == are returning true boolean value ? Because  in order to save memory, two instances of the
     following wrapper objects will always be == when their primitive values are the same :
        - Boolean
        - Byte
        - Character from \u0000 to \uoo7f( 7f is 127 in decimal )
        - Short and Integer from -128 to 127

The Java 7 “Diamond” Syntax
---------------------------

    .. code-block:: python
       :linenos:

        Instead of writing :
        List<Dog> myDogs = new ArrayList<Dog>()or
        Map<String, Dog> dogMap = new HashTable<String, Dog>();

        you can write:

        List<Dog> myDogs = new ArrayList<>();
        Map<String, Dog> dogMap = new HashTable<>();

The Comparable Interface
------------------------
    - The Comparable interface is used by the Collections.sort() method and the java.util.Arrays.sort() method to sort Lists and arrays of objects.
    - To implement Comparable, a class must implement a single method compareTo();
    - int x = thisObject.compareTo(anotherObject):
        - Negative  : if thisObject < anotherObject
        - Zero : if thisObject == anotherObject
        - Positive  : if thisObject > anotherObject

Sorting with Comparator
-----------------------
    - The Comparator interface gives you the capability to sort a given collection any number of different ways.
    - The other handy thing about the Comparator interface is that you can use it to sort instances of any class - even classes
      you can’t modify - unlike Comparable interface, which force you to change the class whose instances you want to sort


    .. code-block:: python
       :linenos:

        Example :
        class genreSort implements Comparator<DvdInfo>{
            public int compare(DvdInfo one, DvdInfo two){
                ….
            }
        }

Cross platform
--------------
    - cross platforms means that code written in one platform can be executed on another platform without change
    - Java provides cross platform by converting .java files to .class files ( binary files ) which will be executed on the corresponding JVM

Early bindings vs late bindings
-------------------------------
    - Connecting a method call to a method body is called binding
    - The compiler cannot make a function call in the traditional sense
    - The function call generated by a non-OOP compiler causes what is called early binding, a term you may not have heard before because you’ve never thought
      about it any other way

    - It means the compiler generates a call to a specific function name, and the runtime system resolves this call to the absolute address of the code to be executed
    - In OOP, the program cannot determine the address of the code until run time, so some other scheme is necessary when a message is sent to a generic object.
    - To solve the problem, object-oriented languages use the concept of late binding ( or runtime binding, or dynamic binding).
    - When you send a message to an object, the code being called isn’t determined until run time
    - The compiler does ensure that the method exists and performs type checking on the arguments and return value, but it doesn’t know the exact code to execute.
    - When a language implements late binding, there must be some mechanism to determine the type of the object at run time and to call the appropriate method
    - To perform late binding, Java uses a special bit of code in lieu of the absolute call
    - This code calculates the address of the method body, using information stored in the object
    - All method binding in Java uses late binding unless the method is static or final (private methods are implicitly final)

    - Why would you declare a method final?
        - it prevents anyone from overriding that method
        - more important, it effectively “turns off” dynamic binding

Multiple containers
-------------------
    - There are two reasons that you need a choice of containers
        - containers provide different types of interfaces and external behavior:
	        - A stack has a different interface and behavior than a queue, which is different from a set or a list
            - One of these might provide a more flexible solution to your problem than the other
        - different containers have different efficiencies for certain operations

Places of storing data
----------------------
    - There are five different places to store data:
        - Registers
            - This is the fastest storage because it exists in a place different from that of other storage: inside the processor. 
            - However, the number of registers is severely limited, so registers are allocated as they are needed
            - You don’t have direct control, nor do you see any evidence in your programs that registers even exist
        - The stack
            - This lives in the general random-access memory (RAM) area but has direct support from the processor via its stack pointer
            - The stack pointer is moved down to create new memory and moved up to release that memory
            - This is an extremely fast and efficient way to allocate storage, second only to registers
            - The Java system must know, while it is creating the program, the exact lifetime of all the items that are stored on the stack
            - This constraint places limits on the flexibility of your programs, so while some Java storage exists on the stack—in particular,
              object references—Java objects themselves are not placed on the stack.

        - The heap
            - This is a general-purpose pool of memory (also in the RAM area) where all Java objects live
            - The nice thing about the heap is that, unlike the stack, the compiler doesn’t need to know how long that storage must stay on the heap
            - Whenever you need an object, you simply write the code to create it by using new, and the storage is allocated on the heap when that code is executed
            - It may take more time to allocate and clean up heap storage than stack storage
        - Constant storage
            - Constant values are often placed directly in the program code, which is safe since they can never change
            - Sometimes constants are cordoned off by themselves so that they can be optionally placed in read-only memory (ROM), in embedded systems
        - Non-RAM storage
            - If data lives completely outside a program, it can exist while the program is not running, outside the control of the program
            - The two primary examples of this are streamed objects, in which objects are turned into streams of bytes, generally to be sent to another machine,
              and persistent objects, in which the objects are placed on disk so they will hold their state even when the program is terminated

            - The trick with these types of storage is turning the objects into something that can exist on the other medium, and yet can be
              resurrected into a regular RAM-based object when necessary

            - Java provides support for lightweight persistence, and mechanisms such as JDBC and Hibernate provide more sophisticated support for storing and
              retrieving object information in databases.

Short-circuiting
----------------
    - When dealing with logical operators, you run into a phenomenon called “short-circuiting.” This means that the expression will be evaluated only until the truth or falsehood of the entire expression can be unambiguously determined. 
    - As a result, the latter parts of a logical expression might not be evaluated

Orders of constructors calls
----------------------------
    - the order of constructor calls for a complex object is as follows:
        - The base-class constructor is called. This step is repeated recursively such that the root of the hierarchy is constructed first,
          followed by the next-derived class, etc., until the most-derived class is reached.

        - Member initializers are called in the order of declaration.
        - The body of the derived-class constructor is called.

Calling dynamically-bound method (or instance method) in constructor
--------------------------------------------------------------------
    - the dynamically-bound method is resolved at runtime, because the object cannot know whether it belongs to the class that method is or derived class
    - calling a method which can be overridden inside constructor might bring to wrong values as the constructor for that derived class is not called, but
      the overridden method is executed

Classes inside interfaces
-------------------------
    - Any class you put inside an interface is automatically public and static

Closures & Callbacks
--------------------
    - A closure is a callable object that retains information from the scope in which it was created.
    - example : an inner class is an object-oriented closure, because it holds a reference back to the whole outer-class object
    - With a callback, some other object is given a piece of information that allows it to call back into the originating object at some later point
    - Caller takes an Incrementable reference in its constructor and then, sometime later, uses the reference to "call back" into the Callee class.


:ref:`Go Back <java-label>`.